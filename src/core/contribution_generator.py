import os
import random
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Tuple
from git import Repo, Actor
import logging
from dataclasses import dataclass
import json
from enum import Enum
from pathlib import Path

class CommitPattern(Enum):
    RANDOM = "random"
    WORK_HOURS = "work_hours"
    CONSISTENT = "consistent"
    BURST = "burst"

@dataclass
class CommitConfig:
    min_commits_per_day: int = 1
    max_commits_per_day: int = 5
    commit_pattern: CommitPattern = CommitPattern.WORK_HOURS
    work_start_hour: int = 9
    work_end_hour: int = 18
    skip_weekends: bool = True
    contribution_frequency: float = 0.7
    commit_messages: List[str] = None

class ContributionStats:
    def __init__(self):
        self.total_commits: int = 0
        self.commits_by_date: Dict[str, int] = {}
        self.start_date: Optional[datetime] = None
        self.end_date: Optional[datetime] = None
        
    def to_json(self) -> str:
        return json.dumps({
            'total_commits': self.total_commits,
            'commits_by_date': self.commits_by_date,
            'start_date': self.start_date.isoformat() if self.start_date else None,
            'end_date': self.end_date.isoformat() if self.end_date else None
        }, indent=2)

class DateHandler:
    @staticmethod
    def get_date_range(start_date: datetime, end_date: datetime) -> List[datetime]:
        return [start_date + timedelta(days=x) for x in range((end_date - start_date).days + 1)]
    
    @staticmethod
    def is_weekend(date: datetime) -> bool:
        return date.weekday() >= 5
    
    @staticmethod
    def is_work_hours(time: datetime, start_hour: int, end_hour: int) -> bool:
        return start_hour <= time.hour < end_hour
    
    @staticmethod
    def get_random_time_in_range(date: datetime, start_hour: int, end_hour: int) -> datetime:
        minutes = random.randint(0, (end_hour - start_hour) * 60)
        return date.replace(hour=start_hour) + timedelta(minutes=minutes)

class ContributionGenerator:
    """
    Enhanced class for generating Git contributions with various patterns and configurations.
    """
    
    def __init__(self, repo_path: str, author_name: str = None, author_email: str = None):
        self.repo_path = Path(repo_path)
        self.repo: Optional[Repo] = None
        self.stats = ContributionStats()
        self.author_name = author_name or "Federico Nicolas Báez"
        self.author_email = author_email or "federiconbaez@gmail.com"
        self.author = Actor(self.author_name, self.author_email)
        self._setup_logging()
        self._initialize_repo()

    def _setup_logging(self):
        """Configure logging with proper format and handlers."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.repo_path / 'contribution_generator.log'),
                logging.StreamHandler()
            ]
        )

    def _initialize_repo(self):
        """Initialize or load the git repository with proper error handling."""
        try:
            self.repo_path.mkdir(parents=True, exist_ok=True)
            git_dir = self.repo_path / '.git'
            
            if not git_dir.exists():
                self.repo = Repo.init(self.repo_path)
                self._create_initial_structure()
                logging.info(f"Initialized new git repository at {self.repo_path}")
            else:
                self.repo = Repo(self.repo_path)
                logging.info(f"Loaded existing git repository at {self.repo_path}")
                
            # Verify repository state
            if self.repo.bare:
                raise ValueError("Repository should not be bare")
                
        except Exception as e:
            logging.error(f"Repository initialization failed: {str(e)}")
            raise

    def _create_initial_structure(self):
        """Create initial repository structure with basic files."""
        readme_path = self.repo_path / 'README.md'
        gitignore_path = self.repo_path / '.gitignore'
        
        # Create README.md
        readme_content = f"""# Contribution Repository
Generated by ContributionGenerator
Initial creation: {datetime.now().isoformat()}
"""
        readme_path.write_text(readme_content)
        
        # Create .gitignore
        gitignore_content = """
*.log
*.pyc
__pycache__/
.env
.venv/
"""
        gitignore_path.write_text(gitignore_content)
        
        # Initial commit
        self.repo.index.add(['README.md', '.gitignore'])
        self.repo.index.commit("Initial repository setup", author=self.author)

    def generate_contributions(self, config: CommitConfig, start_date: datetime, end_date: datetime) -> ContributionStats:
        """
        Generate git contributions based on the provided configuration and date range.
        
        Args:
            config: CommitConfig object containing generation parameters
            start_date: Start date for contributions
            end_date: End date for contributions
            
        Returns:
            ContributionStats object with generation statistics
        """
        self.stats = ContributionStats()
        self.stats.start_date = start_date
        self.stats.end_date = end_date
        
        try:
            date_range = DateHandler.get_date_range(start_date, end_date)
            
            for date in date_range:
                if config.skip_weekends and DateHandler.is_weekend(date):
                    continue
                    
                if random.random() > config.contribution_frequency:
                    continue
                    
                commits_today = self._generate_daily_commits(date, config)
                self.stats.commits_by_date[date.strftime('%Y-%m-%d')] = commits_today
                self.stats.total_commits += commits_today
                
            logging.info(f"Successfully generated {self.stats.total_commits} commits")
            self._save_stats()
            return self.stats
            
        except Exception as e:
            logging.error(f"Contribution generation failed: {str(e)}")
            raise

    def _generate_daily_commits(self, date: datetime, config: CommitConfig) -> int:
        """Generate commits for a single day based on the commit pattern."""
        commits_count = random.randint(config.min_commits_per_day, config.max_commits_per_day)
        commit_times = self._generate_commit_times(date, commits_count, config)
        
        for commit_time in commit_times:
            self._create_commit(commit_time, config)
            
        return len(commit_times)

    def _generate_commit_times(self, date: datetime, count: int, config: CommitConfig) -> List[datetime]:
        """Generate commit times based on the specified pattern."""
        if config.commit_pattern == CommitPattern.WORK_HOURS:
            return [
                DateHandler.get_random_time_in_range(date, config.work_start_hour, config.work_end_hour)
                for _ in range(count)
            ]
        elif config.commit_pattern == CommitPattern.BURST:
            base_time = DateHandler.get_random_time_in_range(
                date, config.work_start_hour, config.work_end_hour
            )
            return [base_time + timedelta(minutes=i*15) for i in range(count)]
        else:  # RANDOM pattern
            return [
                date + timedelta(minutes=random.randint(0, 1440))
                for _ in range(count)
            ]

    def _create_commit(self, commit_date: datetime, config: CommitConfig):
        """
        Create a single commit with proper message and date.
        
        Args:
            commit_date (datetime): The date for the commit
            config (CommitConfig): Configuration for the commit
        """
        try:
            # Update README with contribution
            readme_path = self.repo_path / 'README.md'
            with readme_path.open('a') as f:
                f.write(f"\nContribution: {commit_date.strftime('%Y-%m-%d %H:%M:%S')}")

            # Create additional file for this commit
            commit_file = self.repo_path / f'contributions/commit_{commit_date.strftime("%Y%m%d_%H%M%S")}.txt'
            commit_file.parent.mkdir(exist_ok=True)
            commit_file.write_text(f"Contribution generated at {commit_date.strftime('%Y-%m-%d %H:%M:%S')}")

            # Prepare commit message
            if config.commit_messages and len(config.commit_messages) > 0:
                message = random.choice(config.commit_messages)
            else:
                message = f"Contribution: {commit_date.strftime('%Y-%m-%d %H:%M:%S')}"

            # Format dates properly for Git
            formatted_date = commit_date.strftime('%Y-%m-%d %H:%M:%S')

            # Create commit with properly formatted date
            self.repo.index.add([
                str(readme_path.relative_to(self.repo_path)),
                str(commit_file.relative_to(self.repo_path))
            ])
            
            self.repo.index.commit(
                message,
                author=self.author,
                author_date=formatted_date,
                committer=self.author,
                commit_date=formatted_date
            )
            
            logging.info(f"Created commit for {formatted_date}")

        except Exception as e:
            logging.error(f"Failed to create commit for {commit_date}: {str(e)}")
            raise

    def _save_stats(self):
        """Save contribution statistics to a JSON file."""
        stats_file = self.repo_path / 'contribution_stats.json'
        stats_file.write_text(self.stats.to_json())

    def push_to_remote(self, remote_url: str, branch: str = "develop"):
        """Push generated contributions to a remote repository."""
        try:
            if "origin" not in [remote.name for remote in self.repo.remotes]:
                self.repo.create_remote("origin", remote_url)
            
            origin = self.repo.remote("origin")
            origin.push(branch)
            logging.info(f"Successfully pushed to remote: {remote_url}")
            
        except Exception as e:
            logging.error(f"Failed to push to remote: {str(e)}")
            raise

    def generate_contributions_over_period(self, days: int, max_commits_per_day: int):
        """Generate contributions over a specified number of days."""
        try:
            curr_date = datetime.now()
            start_date = curr_date - timedelta(days=days)
            end_date = curr_date + timedelta(days=1)
            
            self.generate_contributions(
                CommitConfig(max_commits_per_day=max_commits_per_day),
                start_date, end_date
            )
            
        except Exception as e:
            logging.error(f"Failed to generate contributions over {days} days: {str(e)}")
            raise

# Example usage
if __name__ == "__main__":
    # Configuration example
    config = CommitConfig(
        min_commits_per_day=1,
        max_commits_per_day=5,
        commit_pattern=CommitPattern.WORK_HOURS,
        work_start_hour=9,
        work_end_hour=18,
        skip_weekends=True,
        contribution_frequency=0.7,
        commit_messages=[
            "Update documentation",
            "Add new feature",
            "Fix bug",
            "Improve performance",
            "Refactor code"
        ]
    )
    
    generator = ContributionGenerator(
        repo_path="./test_repo",
        author_name="Federico Nicolas Báez",
        author_email="federiconbaez@gmail.com"
    )
    
    end_date = datetime.now()
    start_date = end_date - timedelta(days=30)
    
    stats = generator.generate_contributions(config, start_date, end_date)
    print(f"Generated {stats.total_commits} commits")